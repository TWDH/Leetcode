#### [912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

![image-20210602171916968](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210602171916968.png)

## 1.快速排序

1. 选定中心的 `pivot`
2. 核心思想：`pivot左面 < pivot`；`pivot右面 > pivot`
   1. 找到两侧第一个不符合要求的数组，进行交换
3. **==left <= right==**：否则会出现 Stack Overflow，[1, 2] 数据规模一直不变。
4. ==**A[left] < pivot**==：也会出现Stack Overflow，需要**左右均分**
   1. 找到左面第一个==**大于等于**== `pivot`的值
5. 注意：`right` 指针，结束循环时会在 `left` 指针 **左面**
   1. 所以再次 quicksort 的时候，`[start, right]`，`[left, end]` 进行排序

```java
class Solution {
    public int[] sortArray(int[] nums) {
        // 1. quickSort(array, start, end)
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }

    // 快速排序
    private void quickSort(int[] nums, int start, int end){
        // 1.边界条件
        if(start >= end){
            return;
        }

        // 2. 选取中点作为 pivot
        int pivot = nums[start + (end - start) / 2];
        int left = start;
        int right = end;

        // 3. 找到两侧第一个不符合要求的数组，进行交换
        // 注意：right 指针，结束循环时会在 left 指针左面
        while(left <= right){
            // 找到大于的pivot
            // pivot左面 < pivot
            while(left <= right && nums[left] < pivot){
                left++;
            }
            // 找到小于 pivot的
            // pivot右面 > pivot
            while(left <= right && nums[right] > pivot){
                right--;
            }

            // 交换
            if(left <= right){
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;

                //更新两指针位置
                left++;
                right--;
            }
        }
        // [start, right] 
        quickSort(nums, start, right);
        // [left, end]
        quickSort(nums, left, end);
    }
}
```


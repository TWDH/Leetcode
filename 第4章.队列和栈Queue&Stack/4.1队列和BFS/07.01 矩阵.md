# 01 矩阵

![image-20210115211853521](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210115211853521.png)

## 方法一：BFS

1. 首先遍历整个数组，将**先把0周围的1添加入queue(最外层的1)**
2. 与此同时，将这些最外层的1，对应的距离数组distance，设置唯一。（最外层这些1需要“1”点距离才能找到0）
3. 将这些最外层的1，入queue
4. 下面只关心在内层的1与外层1的距离即可，内层的1每向里一层就增加1。并将新的（内层的1）加入队列。
5. 每个最外层的1只负责周围4个位置，此时这个1已经出queue。

```java
class Solution {
    int[] dx = {1, 0, 0, -1};
    int[] dy = {0, 1, -1, 0};
    public int[][] updateMatrix(int[][] matrix) {
        int numRow = matrix.length;
        int numCol = matrix[0].length;
        Queue<int[]> queue = new LinkedList<>();
        int[][] distance = new int[numRow][numCol];
        //遍历，找到0的点
        for(int i = 0; i < numRow; i++){
            for(int j = 0; j < numCol; j++){
                //先把0周围的1添加入queue(最外层的1)
                if(matrix[i][j] == 0){
                    for(int k = 0; k < 4; k++){
                        int x = i + dx[k];
                        int y = j + dy[k];
                        if(x >= 0 && x < numRow && y >= 0 && y < numCol && distance[x][y] == 0 && matrix[x][y] == 1){
                            queue.offer(new int[]{x, y});
                            distance[x][y] = 1;
                        }
                    }
                }
            }
        }

        while(!queue.isEmpty()){
            int[] cell = queue.poll();
            int row = cell[0];
            int col = cell[1];
            //每个最外层的1只负责周围4个位置
            for(int i = 0; i < 4; i++){
                int newRow = row + dx[i];
                int newCol = col + dy[i];
                if(newRow >= 0 && newRow < numRow && newCol >= 0 && newCol < numCol && matrix[newRow][newCol] == 1 && distance[newRow][newCol] == 0){
                    distance[newRow][newCol] = distance[row][col]+1;
                    queue.offer(new int[]{newRow, newCol});
                }
            }
        }
        return distance;
    }
}
```





## 方法二：DFS（超时）

```java
class Solution {
    int[] dx = {1, 0, 0, -1};
    int[] dy = {0, 1, -1, 0};

    public int[][] updateMatrix(int[][] matrix) {
        //行列数量
        int numRow = matrix.length;
        int numCol = matrix[0].length;
        //2.遍历每个点
        for(int i = 0; i <numRow; i++){
            for(int j = 0; j < numCol; j++){
                int distance = 0;
                //3.如果当前点就是0
                if(matrix[i][j] == 0){
                    continue;
                }
                //4.开启dfs返回
                int[][] visited = new int[numRow][numCol];
                distance = dfs(matrix, i, j, 0, visited);
                matrix[i][j] = distance;
            }
        }

        return matrix;
    }

    public int dfs(int[][] matrix, int row, int col, int dis, int[][] visited){
        //当找到0时返回
        if(matrix[row][col] == 0){
            return dis;
        }
        visited[row][col] = 1;
        int minDistance = Integer.MAX_VALUE;
        //遍历上下左右
        for(int i = 0; i < 4; i++){
            int newRow = row + dx[i];
            int newCol = col + dy[i];
            
            
            if(newRow >= 0 && newRow < matrix.length && newCol >= 0 && newCol < matrix[0].length){
                if(visited[newRow][newCol] == 1){
                    continue;
                }
                minDistance = Math.min(minDistance, dfs(matrix, newRow, newCol, dis + 1, visited));
                //因为visited标记过的，一个点不会遍历，所以需要每次dfs执行完重置
                visited[newRow][newCol] = 0;
            }
        }
        return minDistance;
    }
}
```


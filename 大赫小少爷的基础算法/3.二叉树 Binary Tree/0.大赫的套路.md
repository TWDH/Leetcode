# 树的遍历

**迭代法**：使用stack控制TreeNode节点

* 根：`res.add(node.val)`  
* 左：`node = node.left`
* 右：`node = node.right`
* 控制出栈入栈：
  * `stack.push(node.val)`
  * `stack.pop()`

整体代码逻辑

```java
while(!stack.isEmpty() || node != null){
    while(node != null){
        ...
        stack.push(node.val);
    }
    ...
    stack.pop();
}
```

# 栈(stack)的使用

![å¨è¿éæå¥å¾çæè¿°](pic/2020053121015811.png)

**不建议**使用stack：效率低，synchronize的问题

Stack：上进上出
Deque：上进上出，上进下出，甚至下进上出

### 栈(stack)的一般初始化

Deque<TreeNode> stack = new LinkedList<>();

### ArrayDeque和LinkedList区别

**ArrayDeque:**

* 数组结构
* 插入元素不能为null
* 无法确定容量时，后期扩容收到影响

**LinkedList**

* 链表结构
* 插入元素可以为null
* 无法确定数据容量，有更好表现

### Deque中的常用方法

#### Deque当做栈使用

|   操作   |                          函数                           |
| :------: | :-----------------------------------------------------: |
|   入栈   |                        push(E e)                        |
|   出栈   | poll() / pop() 后者在栈空的时候会抛出异常，前者返回null |
| 查看栈顶 |                  peek() 为空时返回null                  |

#### Deque当做队列使用

|   操作   |         函数          |
| :------: | :-------------------: |
|   入队   |      offer(E e)       |
|   出队   | poll() 为空时返回null |
| 查看队首 | peek() 为空时返回null |

。。。进阶操作

#### 从上方/头部插入

| **方法名**              |                             作用                             |
| ----------------------- | :----------------------------------------------------------: |
| void addFirst(E e)      |      将指定的元素插入此双端队列的前面 ，空间不足抛异常       |
| boolean offerFirst(E e) | 将指定的元素插入此双端队列的前面 ，空间不足插入失败**返回false** |
| void push(E e)          |      将指定的元素插入此双端队列的前面 ，空间不足抛异常       |


















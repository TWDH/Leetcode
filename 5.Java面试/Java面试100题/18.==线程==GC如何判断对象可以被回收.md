# 18.GC如何判断对象可以被回收

- 引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计
  数为0时可以回收（JAVA不采用）
- 可达性分析法：从 `GC Roots` 开始 **向下搜索**，搜索所走过的路径称为引用链。当一个**对象**到 GC
  Roots **没有任何引用链相连时**，则证明此对象是不可用的，那么虚拟机就判断是可回收对象

> 引用计数法（循环依赖），可能会出现 A 引用了 B，B 又引用了 A，这时候就算他们都不再使用了，但因为相互引用 计数器=1 永远无法被回收。



- `GC Roots` 的对象有：
  - 虚拟机栈(栈帧中的本地变量表）中引用的对象
  - 方法区中**类静态属性**引用的对象
  - 方法区中**常量**引用的对象
  - 本地方法栈中JNI(即一般说的Native方法)引用的对象



- 可达性算法中的 **不可达对象** 并 **不是立即死亡**的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至少要经历两次标记过程：
  - 第一次是经过可达性分析发现没有与 `GC Roots` 相连接的引用链
  - 第二次是在由虚拟机自动建立的Finalizer队列中判断是否需要执行finalize()方法。
    - 当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，
      - 若 *未覆盖*，则直接将其回收。
      - 否则，若对象未执行过 `finalize` 方法，将其放入 `F-Queue` 队列，由一低优先级线程执行该队列中对象的 `finalize` 方法。
        - 执行finalize方法完毕后，GC会 *再次判断* 该对象是否可达
        - 若不可达，则进行回收，否则，对象“复活”



- 每个对象只能触发一次finalize()方法
- 由于finalize()方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，不推荐大家使用，建议遗忘它。
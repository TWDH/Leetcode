# 27.并发的三大特性

## 原子性

- 原子性是指在一个操作中cpu不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要不都不执行。就好比转账，从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。2个操作必须全部完成。

```java
private long count = 0;
public void calc() {
	count++;
}
```

1. 将 i 从主存读到工作内存中的副本中
2. +1的运算
3. 将结果写入工作内存
4. 将工作内存的值刷回主存(什么时候刷入由操作系统决定，不确定的)



那程序中原子性指的是最小的操作单元，比如自增操作，它本身其实并不是原子性操作，分了3步的，包括读取变量的原始值、进行加1操作、写入工作内存。所以在多线程中，有可能一个线程还没自增完，可能才执行到第二部，另一个线程就已经读取了值，导致结果错误。那如果我们能保证自增操作是一个原子性的操作，那么就能保证其他线程读取到的一定是自增后的数据。

关键字：synchronized

## 可见性

- 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
- 若两个线程在不同的cpu，那么线程1改变了 i 的值还没刷新到主存，线程2又使用了 i，那么这个 i 值肯定还是之前的，线程1对变量的修改线程没看到这就是可见性问题。

```java
//线程1
boolean stop = false;
while(!stop){
	doSomething();
}
//线程2
stop = true;
```

如果线程2改变了stop的值，线程1一定会停止吗？不一定。当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。

关键字：volatile、synchronized、final

## 有序性

- 虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按照我们写的代码的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，虽然对变量的值没有造成影响，但有可能会出现线程安全问题。

```java
int a = 0;
bool flag = false;
public void write() {
    a = 2; //1
    flag = true; //2
}
public void multiply() {
    if (flag) { //3
        int ret = a * a;//4
    }
}
```

- write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步

- 关键字：volatile、synchronized
- `volatile` 本身就包含了禁止指令重排序的语义，而 `synchronized` 关键字是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则明确的。



- `synchronized` 关键字同时满足以上三种特性，但是volatile关键字不满足原子性。
- 在某些情况下，volatile的同步机制的性能确实要优于锁(使用 `synchronized` 关键字或 `java.util.concurrent` 包里面的锁)，因为 `volatile` 的总开销要比锁低。
- 我们判断使用 `volatile` 还是加锁的唯一依据就是volatile的语义能否满足使用的场景(原子性)



## volatile

1. 保证被 `volatile` 修饰的共享变量对所有线程总是可见的，也就是当一个线程修改了一个被 `volatile` 修饰共享变量的值，新值总是可以被其他线程立即得知。

```java
//线程1
boolean stop = false;
while(!stop){
	doSomething();
}
//线程2
stop = true;
```

如果线程2改变了stop的值，线程1一定会停止吗？不一定。当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。

2. 禁止指令重排序优化。

```java
int a = 0;
bool flag = false;
public void write() {
    a = 2; //1
    flag = true; //2
}
public void multiply() {
    if (flag) { //3
    	int ret = a * a;//4
    }
}
```

- write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。
- 但是用volatile修饰之后就变得不一样了
  - 第一：使用 `volatile` 关键字会强制将修改的值立即写入主存；
  - 第二：使用 `volatile` 关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；
  - 第三：由于线程1的工作内存中缓存变量 stop 的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。
- inc++; 其实是两个步骤，先加加，然后再赋值。不是原子性操作，所以 `volatile` 不能保证线程安全。














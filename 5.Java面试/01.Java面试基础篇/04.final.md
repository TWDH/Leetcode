# 04.final

## 1. final 作用

- 最终的 
  - 修饰类：表示类不可被继承
  - 修饰方法：表示方法不可被子类重写（但是可以重载？）
  - 修饰变量：表示变量一旦被赋值就不可以更改它的值。 
  - (1) 修饰成员变量
    - 如果 `final` 修饰的是 **类变量** ，只能在 静态初始化块 中指定 初始值 或者 声明该类变量 时指定初始值。
    - 如果 `final` 修饰的是 **成员变量**，可以在非静态初始化块、声明该变量或者构造器中执行初始值。 
  - (2) 修饰局部变量
    - 系统不会为局部变量进行初始化局部变量必须由程序员显示初始化。因此使用final修饰局部变量时，即可以在 定义时指定默认值（后面的代码不能对变量再赋值），也可以不指定默认值，而在后面的代码中对final变量赋初值（仅一次） 
    - ![image-20210515122142466](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210515122142466.png)
  - (3) 修饰 基本类型数据 和 引用类型数据 
    - 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改： 如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。但是引用的值是可变的 
    - ![image-20210515122110870](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210515122110870.png)

## 2. 为什么局部内部类和匿名内部类只能访问局部final变量？



* 局部内部类
  * ![image-20210515122437182](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210515122437182.png)
* 匿名内部类
  * 会生成 2 个 class 文件， test.class 和 test1.class
  * ![image-20210515122310110](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210515122310110.png)

* 首先需要知道的一点是：**内部类**和**外部类**是处于**同一个级别**的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。 
* 这里就会产生问题：当外部类的方法结再时，局部变量就会被销毁了，但是内部类对象可能还存在（只有没有人再 引用它时，才会死亡）。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将**局部变量复制了一份作为内部类的成员变量**，这样当局部变量死亡后内部类仍可以访问它，实际访问的是局部变量的 “copy” 。这样就好像延长了局部变量的生命周期 
* 将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变 量，方法中的局部变量也得跟着改变，怎么解决问题呢？ 
* 就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量就保证了内部类的成员变量和方法的 局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。 


















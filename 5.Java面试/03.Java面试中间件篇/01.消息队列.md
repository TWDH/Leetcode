# 01.消息队列

## 一. 什么是消息队列

我们可以把消息队列看作是一个**存放消息的容器**，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。

![Message queue](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/消息队列/message-queue-small.png)

消息队列是分布式系统中重要的组件之一。使用消息队列主要是为了通过异步处理

- 提高系统性能
- 削峰、降低系统耦合性。

我们知道队列 Queue 是一种 **先进先出** 的数据结构，所以消费消息时也是 **按照顺序** 来消费的。



## 二. 为什么要用消息队列

三点好处：

1. 通过 **异步处理** 提高系统性能（减少响应所需时间）。
2. 削峰/限流
3. 降低系统 **耦合** 性。
   

### 2.1 通过异步处理提高系统性能（减少响应所需时间）

![通过异步处理提高系统性能](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/Asynchronous-message-queue.png)

- 将用户的请求数据 **存储到消息队列** 之后就 **立即返回结果**。随后，**系统再 **对消息进行 **消费**。
- 因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，**使用消息队列进行异步处理之后，需要适当修改业务流程进行配合**，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。



### 2.2 削峰/限流

- 先将**短时间高并发**产生的事务消息**存储在消息队列**中，然后后端服务再**慢慢**根据自己的能力去**消费**这些消息，这样就**避免**直接把后端服务**打垮掉**。

举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：

![削峰](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/削峰-消息队列.png)



### 2.3 降低系统耦合性

使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么 新增模块 或者 修改模块 就对其他模块影响较小，这样系统的可扩展性无疑更好一些。

![解耦](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/消息队列-解耦.png)

- **生产者**（客户端）**发送消**息到 **消息队列** 中去，**接受者**（服务端）处理消息，需要消费的系统直接**去消息队列**取消息**进行消费**即可而**不需要**和**其他系统**有耦合， 这显然也提高了系统的扩展性
- 消息队列使利用 **发布-订阅模式** 工作，消息发送者（生产者）发布消息，**一个**或**多个**消息接受者（消费者）订阅消息。 
- 从上图可以看到**消息发送者（生产者）**和**消息接受者（消费者）**之间**没有直接耦合**
  - 消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。
  - 对**新增业务**，只要对该类消息感兴趣，即可**订阅该消息**，对**原有系统**和业务**没有任何影响**，从而实现网站业务的可扩展性设计。

另外，为了**避免**消息队列服务器**宕机**造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者**服务器**上，等消息真正被消费者服务器处理后才删除消息。在**消息队列服务器宕机**后，**生产者**服务器会选择分布式消息队列服务器集群中的**其他服务器**发布消息。



## 三. 使用消息队列带来的一些问题

- **系统可用性降低：** 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你**不用考虑消息丢失**或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！
- **系统复杂性提高：** 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！
- **一致性问题：** 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!



## 四. AMQP

- AMQP，即 `Advanced Message Queuing Protocol`，一个提供统一消息服务的应用层标准 **高级消息队列协议**（二进制应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。
- **RabbitMQ** 就是基于 AMQP 协议实现的。



## 五. 常见的消息队列对比

| 对比方向 |                             概要                             |
| :------- | :----------------------------------------------------------: |
| 吞吐量   | 万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。 |
| 可用性   | 都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
| 时效性   | RabbitMQ 基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。 |
| 功能支持 | 除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 |
| 消息丢失 | ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。 |

**总结：**

- ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。
- RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。
- RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的
- Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。








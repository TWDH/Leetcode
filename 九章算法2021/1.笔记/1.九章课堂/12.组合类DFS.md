

# 组合类 DFS

* 搜索所有方案
* **树状结构**

### 1.subsets

* 每个数：选 或 不选

![image-20210401134815973](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210401134815973.png)

* 回溯 Backtracking

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    
    public List<List<Integer>> subsets(int[] nums) {
        //1.定义走过的路径track
        ArrayList<Integer> track = new ArrayList<>();
        //2.开启backtrace
        backtrack(nums, 0, track);
        
        return res;
    }
    
    public void backtrack(int[] nums, int start, ArrayList<Integer> track){
        res.add(new ArrayList<>(track));
        //2.在列表中做选择
        for(int i = start; i < nums.length; i++){
            //2.1 将当前值加入track
            track.add(nums[i]);
            //2.2 回溯，加入下一个数字。进入下一层
            backtrack(nums, i + 1, track);
            //2.3 撤销操作
            track.remove(track.size() - 1);
        }
    }
    
}
```

### 2.subset + 去重

* 去重：当i大于初始值startIndex，并且重复的时候，第二个相同的数字continue
  * 以树的视角看[1, 2] -> [1, 3]
  * 同一层的两个subset中，
    * 第二个数 和 第一个数 **相等**
    * 第二个数在第一个数**之后出现**
  * 说明已经重复
* 排序！

![image-20210401145655797](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20210401145655797.png)

* Hash

```java
public class Solution {
    /**
     * @param nums: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> subsets = new ArrayList<>();
        HashMap<String, Boolean> visited = new HashMap<String, Boolean>();
        Arrays.sort(nums);
        dfs(nums, 0, new ArrayList<>(), subsets, visited);
        
        return subsets;
    }
    
    String getHash(List<Integer> subset) {
        String hashString = "";
        for (int i = 0;i < subset.size(); i++) {
            hashString += subset.get(i).toString();
            hashString += "_";
        }
        
        return hashString;
    }
    
    void dfs(int[] nums, 
             int startIndex, 
             List<Integer> subset,
             List<List<Integer>> subsets,
             HashMap<String, Boolean> visited) {
        String hashString = getHash(subset);
        
        if (visited.containsKey(hashString)) {
            return ;
        }
        
        visited.put(hashString, true);
        subsets.add(new ArrayList<Integer>(subset));
        for (int i = startIndex;i < nums.length; i++) {
            subset.add(nums[i]);
            dfs(nums, i + 1, subset, subsets, visited);
            subset.remove(subset.size() - 1);
        }
        
    }
    
}
```


# 8.二叉树的序列化与反序列化(297)

![image-20201202204237364](https://raw.githubusercontent.com/TWDH/Leetcode-From-Zero/pictures/img/image-20201202204237364.png)

## 方法一：递归 (前序遍历)

[请首先阅读：二叉树序列化](../d.大赫的套路-二叉树序列化.md)

```java
public class Codec {
    String NULL = "#";
    String SEP = ",";

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        //前序遍历的Serialize
        StringBuilder sb = new StringBuilder();
        preSerialize(root, sb);
        return sb.toString();
    }
    
    public void preSerialize(TreeNode root, StringBuilder sb){
        //1.base case
        if(root == null){
            sb.append(NULL).append(SEP);
            return;
        }
        //2.preOrder serialize
        sb.append(root.val).append(SEP);

        preSerialize(root.left, sb);
        preSerialize(root.right, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        //将String转为列表
        LinkedList<String> nodes = new LinkedList<>();
        for(String s : data.split(SEP)){
            nodes.addLast(s);
        }
        return preDeserialize(nodes);
    }

    public TreeNode preDeserialize(LinkedList<String> nodes){
        //1.base case
        if(nodes.isEmpty()){
            return null;
        }

        //2.preDeserialize
        String first = nodes.removeFirst();
        if(first.equals(NULL)){
            return null;
        }
        TreeNode root = new TreeNode(Integer.parseInt(first));

        //3.左右子树
        root.left = preDeserialize(nodes);
        root.right = preDeserialize(nodes);

        return root;
    }
}
```

